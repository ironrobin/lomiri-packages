diff --git a/CMakeLists.txt b/CMakeLists.txt
index be9a7c8..2abd437 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,7 +14,7 @@
 #
 # Authored by: Thomas Voss <thomas.voss@canonical.com>
 
-cmake_minimum_required(VERSION 2.8)
+cmake_minimum_required(VERSION 3.5)
 
 project(dbus-cpp)
 
diff --git a/cmake/PrePush.cmake b/cmake/PrePush.cmake
index aba8823..5ad88a9 100644
--- a/cmake/PrePush.cmake
+++ b/cmake/PrePush.cmake
@@ -79,4 +79,7 @@ add_custom_target(
 add_dependencies(extract-pre-push-tarball pre-push-source-tarball)
 add_dependencies(pdebuild extract-pre-push-tarball)
 
-add_dependencies(pre-push pdebuild android-build)
+add_dependencies(pre-push pdebuild)
+if (TARGET android-build)
+  add_dependencies(pre-push android-build)
+endif()
diff --git a/include/core/dbus/asio/executor.h b/include/core/dbus/asio/executor.h
index 505a55b..9ab83b4 100644
--- a/include/core/dbus/asio/executor.h
+++ b/include/core/dbus/asio/executor.h
@@ -18,7 +18,7 @@
 #ifndef CORE_DBUS_ASIO_EXECUTOR_H_
 #define CORE_DBUS_ASIO_EXECUTOR_H_
 
-#include <boost/asio/io_service.hpp>
+#include <boost/asio/io_context.hpp>
 
 #include <core/dbus/bus.h>
 #include <core/dbus/executor.h>
@@ -31,7 +31,7 @@ namespace dbus
 namespace asio
 {
 ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus);
-ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus, boost::asio::io_service& io);
+ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus, boost::asio::io_context& io);
 }
 }
 }
diff --git a/src/core/dbus/asio/executor.cpp b/src/core/dbus/asio/executor.cpp
index d3357f5..fdfda3e 100644
--- a/src/core/dbus/asio/executor.cpp
+++ b/src/core/dbus/asio/executor.cpp
@@ -22,10 +22,13 @@
 #include <core/dbus/traits/watch.h>
 
 #include <boost/asio.hpp>
-#include <boost/asio/io_service.hpp>
+#include <boost/asio/io_context.hpp>
+#include <boost/asio/steady_timer.hpp>
+#include <boost/system/error_code.hpp>
 
 #include <stdexcept>
 
+#include <chrono>
 #include <condition_variable>
 #include <memory>
 #include <mutex>
@@ -101,9 +104,10 @@ public:
     template<typename UnderlyingTimeoutType = DBusTimeout>
     struct Timeout : std::enable_shared_from_this<Timeout<UnderlyingTimeoutType>>
     {
-        Timeout(boost::asio::io_service& io_service, UnderlyingTimeoutType* timeout)
-            : io_service(io_service),
-              timer(io_service),
+        using Clock = std::chrono::steady_clock;
+        Timeout(boost::asio::io_context& io_context, UnderlyingTimeoutType* timeout)
+            : io_context(io_context),
+              timer(io_context),
               timeout(timeout)
         {
             if (!timeout)
@@ -125,10 +129,8 @@ public:
             // We do not keep ourselves alive to prevent from races during destruction.
             std::weak_ptr<Timeout<UnderlyingTimeoutType>> wp{this->shared_from_this()};
 
-            timer.expires_from_now(
-                        boost::posix_time::milliseconds(
-                            traits::Timeout<UnderlyingTimeoutType>::get_timeout_interval(
-                                timeout)));
+            auto ms = traits::Timeout<UnderlyingTimeoutType>::get_timeout_interval(timeout);
+            timer.expires_after(std::chrono::milliseconds(ms));
             timer.async_wait([wp](const boost::system::error_code& ec)
             {
                 auto sp = wp.lock();
@@ -160,16 +162,19 @@ public:
             traits::Timeout<UnderlyingTimeoutType>::invoke_timeout_handler(timeout);
         }
 
-        boost::asio::io_service& io_service;
-        boost::asio::deadline_timer timer;
+        boost::asio::io_context& io_context;
+        boost::asio::steady_timer timer;
         UnderlyingTimeoutType* timeout;
     };
 
     template<typename UnderlyingWatchType = DBusWatch>
     struct Watch : std::enable_shared_from_this<Watch<UnderlyingWatchType>>
     {
-        Watch(boost::asio::io_service& io_service, UnderlyingWatchType* watch) : io_service(io_service),
-            stream_descriptor(io_service),
+        using Descriptor = boost::asio::posix::stream_descriptor;
+        using WaitType   = Descriptor::wait_type; // alias of descriptor_base::wait_type
+        
+        Watch(boost::asio::io_context& io_context, UnderlyingWatchType* watch) : io_context(io_context),
+            stream_descriptor(io_context),
             watch(watch)
         {
             if (!watch)
@@ -178,7 +183,8 @@ public:
 
         ~Watch() noexcept
         {
-            stream_descriptor.cancel();
+            boost::system::error_code ec;
+            stream_descriptor.cancel(ec);
             stream_descriptor.release();
         }
 
@@ -195,45 +201,30 @@ public:
 
             if (traits::Watch<UnderlyingWatchType>::is_watch_monitoring_fd_for_readable(watch))
             {
-                stream_descriptor.async_read_some(boost::asio::null_buffers(), [wp](boost::system::error_code ec, std::size_t bytes_transferred)
-                {
-                    auto sp = wp.lock();
-
-                    if (sp)
+                stream_descriptor.async_wait(WaitType::wait_read, [wp](const boost::system::error_code& ec) {
+                    if (auto sp = wp.lock())
                         sp->on_stream_descriptor_event(
-                                    traits::Watch<UnderlyingWatchType>::readable_event(),
-                                    ec,
-                                    bytes_transferred);
+                            traits::Watch<UnderlyingWatchType>::readable_event(), ec);
                 });
             }
 
             if (traits::Watch<UnderlyingWatchType>::is_watch_monitoring_fd_for_writable(watch))
             {
-                stream_descriptor.async_write_some(boost::asio::null_buffers(), [wp](boost::system::error_code ec, std::size_t bytes_transferred)
-                {
-                    auto sp = wp.lock();
-
-                    if (sp)
+                stream_descriptor.async_wait(WaitType::wait_write, [wp](const boost::system::error_code& ec) {
+                    if (auto sp = wp.lock())
                         sp->on_stream_descriptor_event(
-                                    traits::Watch<UnderlyingWatchType>::writeable_event(),
-                                    ec,
-                                    bytes_transferred);
+                            traits::Watch<UnderlyingWatchType>::writeable_event(), ec);
                 });
             }
         }
 
         void cancel()
         {
-            try
-            {
-                stream_descriptor.cancel();
-            }
-            catch (...)
-            {
-            }
+            boost::system::error_code ec;
+            stream_descriptor.cancel(ec);
         }
 
-        void on_stream_descriptor_event(int event, const boost::system::error_code& error, std::size_t)
+        void on_stream_descriptor_event(int event, const boost::system::error_code& error)
         {
             if (error == boost::asio::error::operation_aborted)
             {
@@ -255,9 +246,9 @@ public:
             }
         }
 
-        boost::asio::io_service& io_service;
-        boost::asio::posix::stream_descriptor stream_descriptor;
-        UnderlyingWatchType* watch;
+        boost::asio::io_context& io_context;
+        Descriptor               stream_descriptor;
+        UnderlyingWatchType*     watch;
     };
 
     template<typename T>
@@ -281,7 +272,7 @@ public:
             return TRUE;
 
         auto thiz = static_cast<Executor*>(data);
-        auto w = std::shared_ptr<Watch<>>(new Watch<>(thiz->io_service, watch));
+        auto w = std::shared_ptr<Watch<>>(new Watch<>(thiz->io, watch));
         auto holder = new Holder<std::shared_ptr<Watch<>>>(w);
         dbus_watch_set_data(watch, holder, Holder<std::shared_ptr<Watch<>>>::ptr_delete);
 
@@ -309,7 +300,7 @@ public:
     static dbus_bool_t on_dbus_add_timeout(DBusTimeout* timeout, void* data)
     {
         auto thiz = static_cast<Executor*>(data);
-        auto t = std::shared_ptr<Timeout<>>(new Timeout<>(thiz->io_service, timeout));
+        auto t = std::shared_ptr<Timeout<>>(new Timeout<>(thiz->io, timeout));
         auto holder = new Holder<std::shared_ptr<Timeout<>>>(t);
         dbus_timeout_set_data(
                     timeout,
@@ -335,18 +326,15 @@ public:
     {
         auto thiz = static_cast<Executor*>(data);
         auto bus = thiz->bus;
-        thiz->io_service.post([bus]()
-        {
+        boost::asio::post(thiz->io, [bus] {
             while (dbus_connection_get_dispatch_status(bus->raw()) == DBUS_DISPATCH_DATA_REMAINS)
-            {
                 dbus_connection_dispatch(bus->raw());
-            }
         });
     }
 
 public:
 
-    Executor(const Bus::Ptr& bus, boost::asio::io_service& io) : bus(bus), io_service(io), work(io_service)
+    Executor(const Bus::Ptr& bus, boost::asio::io_context& io) : bus(bus), io(io), work(boost::asio::make_work_guard(io))
     {
         if (!bus)
             throw std::runtime_error("Precondition violated, cannot construct executor for null bus.");
@@ -383,27 +371,28 @@ public:
 
     void run()
     {
-        io_service.run();
+        io.run();
     }
 
     void stop()
-    {
-        io_service.stop();
+    { 
+        work.reset(); 
+        io.stop(); 
     }
 
 private:
     Bus::Ptr bus;
-    boost::asio::io_service& io_service;
-    boost::asio::io_service::work work;
+    boost::asio::io_context& io;
+    boost::asio::executor_work_guard<boost::asio::io_context::executor_type> work;
 };
 
 ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus)
 {
-    static boost::asio::io_service io;
+    static boost::asio::io_context io;
     return std::make_shared<core::dbus::asio::Executor>(bus, io);
 }
 
-ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus, boost::asio::io_service& io)
+ORG_FREEDESKTOP_DBUS_DLL_PUBLIC Executor::Ptr make_executor(const Bus::Ptr& bus, boost::asio::io_context& io)
 {
     return std::make_shared<core::dbus::asio::Executor>(bus, io);
 }
diff --git a/tests/executor_test.cpp b/tests/executor_test.cpp
index 1661e4b..f13bbea 100644
--- a/tests/executor_test.cpp
+++ b/tests/executor_test.cpp
@@ -58,7 +58,7 @@ struct ChaosMonkey
 struct Executor : public core::dbus::testing::Fixture
 {
  protected:
-    boost::asio::io_service io_service;
+    boost::asio::io_context io_service;
 };
 
 auto session_bus_config_file =
 